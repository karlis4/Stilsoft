		Задание 1


А) Инициализация и присваивание – это два различных понятия в программировании, хотя они тесно связаны.

Инициализация – это процесс присвоения начального значения переменной в момент её создания. Когда переменная инициализируется, она получает своё первое значение. Например, в языке C++ инициализация может выглядеть так:

int number = 10; // Инициализация переменной number значением 10
Присваивание – это процесс установки или изменения значения переменной после её создания. Присваивание может происходить множество раз после инициализации. Пример присваивания в C++:

number = 20; // Присваивание переменной number нового значения 20
Таким образом, ключевое отличие заключается в том, что инициализация происходит один раз для установки начального значения, а присваивание может использоваться многократно для изменения значения переменной.

Б) Неопределенное поведение в C++ возникает, когда код содержит одну или несколько операций, результат которых не определен стандартом языка. Это может произойти в различных ситуациях, например:

Обращение к памяти после её освобождения.
Изменение объекта более одного раза между двумя последовательными точками последовательности без гарантированной синхронизации.
Чтение неинициализированных переменных.
Превышение диапазона значений переменных типа int.
Деление на ноль.
Последствия неопределенного поведения могут быть очень серьёзными и варьироваться от запуска до запуска программы. Вот некоторые из них:

Сбои программы: Программа может аварийно завершиться или вызвать ошибку времени выполнения.
Непредсказуемые результаты: Программа может продолжать работать, но выдавать неправильные или непредсказуемые результаты.
Проблемы с безопасностью: Неопределенное поведение может привести к уязвимостям в безопасности, таким как буферные переполнения, которые могут быть использованы злоумышленниками.
Оптимизация компилятора: Компилятор может оптимизировать код таким образом, что логика программы изменится или будет удалена.
Избегать неопределенного поведения важно для написания надёжного и безопасного кода на C++. Для этого следует тщательно проверять код на предмет потенциальных проблем и использовать статические анализаторы кода, которые могут помочь обнаружить такие ситуации.


		


					Задание 3

3)Когда точка выполнения находится в функции `d()`, стек вызовов будет выглядеть следующим образом, начиная с вершины стека:

1. `d` - текущая точка выполнения.
2. `b` - функция `b()` вызвала `d()`.
3. `a` - функция `a()` вызвала `b()`.
4. `main` - функция `main()` вызвала `a()`.

Стек вызовов отражает порядок, в котором функции были вызваны и должны вернуть управление после завершения своего выполнения. Каждый новый вызов функции помещает запись на вершину стека, а завершение функции удаляет запись с вершины стека.



				Задание 4
1) Использование литеральных констант (также известных как магические числа) в программе затрудняет ее понимание и изменение. Символьные константы помогают документировать то, что на самом деле представляют числа, а изменение символьной константы при ее объявлении изменяет значение везде, где она используется. Константы с #define не отображаются в отладчике и могут создавать конфликты имен.

2)Выберите подходящий тип данных для переменной в каждой из следующих ситуаций. Будьте как можно более конкретными. Если ответ является целочисленным типом, выберите int, long или определенный целочисленный тип фиксированной ширины (например, std::int_fast16_t) в зависимости от диапазона значений. Если переменная должна быть константной, укажите это.
a) возраст пользователя (в годах)
int
b) нравится ли пользователю цвет, или нет
bool
c) число пи (3,14159265)
constexpr double
d) количество страниц в учебнике (предположим, что размер важен)
Поскольку книги часто могут иметь более 255 страниц, но, вероятно, никогда не могут содержать более 32 767 страниц, std::int_least16_t здесь – подходящий выбор.
e) длина дивана в метрах с точностью до 2 знаков после запятой
float
f) сколько раз вы моргнули с момента своего рождения (примечание: ответ исчисляется миллионами)
std::int_least32_t
g) пользователь выбирает пункт в меню, в котором список пунктов пронумерован буквами
char
h) год рождения (при условии, что размер важен)
std::int_least16_t. Положительные числа можно использовать для обозначения дат рождения нашей эры, а отрицательные числа – для обозначения дат рождения до нашей эры.



				Задание 5
Вопрос 1
Вычислите следующее выражение:
a) (5 > 3 && 4 < 8)
(5 > 3 && 4 < 8) становится (true && true), что равно true.
b) (4 > 6 && true)
(4 > 6 && true) становится (false && true), что равно false.
c) (3 >= 3 || false)
(3 >= 3 || false) становится (true || false), что равно true.
d) (true || false) ? 4 : 5
(true || false) ? 4 : 5 становится (true ? 4 : 5), что равно 4.
________________________________________
Вопрос 2
Оцените следующее выражение:
a) 7 / 4
7/4 = 1 и остаток 3, поэтому это выражение равно 1.
b) 14 % 5
14/5 = 2 и остаток 4, поэтому 14 % 5 равно 4.
________________________________________
Вопрос 3
Почему никогда не следует делать следующее:
a) int y{ foo(++x, x) };
Поскольку operator++ применяет к x побочный эффект, мы не должны снова использовать x в том же выражении. В этом случае параметры функции foo() могут быть вычислены в любом порядке, поэтому неизвестно, будет ли сначала вычисляться x или ++x. Поскольку ++x изменяет значение x, неясно, какие значения будут переданы в функцию.
b) double x{ 0.1 + 0.1 + 0.1 }; return (x == 0.3);
Ошибки в вычислениях с плавающей запятой приведут к тому, что возвращаемое значение будет вычислено как false, даже если похоже, что оно должно быть true.
c) int x{ 3 / 0 };
Деление на 0 вызывает неопределенное поведение, которое, вероятно, будет выражено в сбое работы программы.
				Задание 8
1) Какой тип преобразования происходит в каждом из следующих случаев? Допустимые ответы: преобразование не требуется, числовое продвижение, числовое преобразование, не будет компилироваться из-за сужающего преобразования. Предположим, что int и long равны 4 байтам.
int main()
{
    int a{ 5 };     // 1a
    int b{ 'a' };   // 1b
    int c{ 5.4 };   // 1c
    int d{ true };  // 1d
    int e{ static_cast<int>(5.4) }; // 1e
 
    double f { 5.0f }; // 1f
    double g { 5 };    // 1g
 
    // Немного посложнее
    long h{ 5 };     // 1h
 
    float i { f };   // 1i
    float j { 5.0 }; // 1j
 
}
1a) Преобразование не требуется

1b) Целочисленное продвижение char 'a' в int

1c) Не компилируется из-за сужающего преобразования

1d) Числовое продвижение bool true в int

1e) Явное числовое преобразование double 5.4 в int

1f) Числовое продвижение числа float в double

1g) Числовое преобразование int в double

1h)Числовое преобразование int в long (это преобразование тривиально, но это всё же преобразование)

1i) Не компилируется из-за сужающего преобразования из double во float

1j)Числовое преобразование из double во float (оно разрешено, поскольку 5.0 является constexpr и подходит для диапазона значений float)



2b) Она будет компилироваться. И радианы, и градусы являются псевдонимами типа для double, так что это просто присвоение значения double переменной типа double.

3a) Эта программа выведет: int 5

Причина этого в том, что здесь происходит неявное преобразование типа. Переменная `s` имеет тип `short`, который является целочисленным типом данных. Когда `s` передается в функцию `print`, компилятор ищет наиболее подходящую перегрузку функции для вызова.

В данном случае, компилятор выберет функцию `print(int x)`, так как `short` может быть неявно преобразован в `int` без потери данных. Функция `print(double x)` не будет выбрана, потому что преобразование из `short` в `double`, хоть и возможно, но менее предпочтительно, чем преобразование в `int`, так как `int` также является целочисленным типом, как и `short`.

3b) Поскольку параметры с аргументами по умолчанию не учитываются при разрешении перегруженных функций, компилятор не может определить, должен ли вызов print() разрешаться в print() или print(int x = 0).

3c) Значение 5 – это число int. Преобразование int в long или double – это числовое преобразование, и компилятор не сможет определить, какая функция подходит лучше.

4) Вот что выведет программа и почему: 1121

- Первый вызов `count(1)` увеличивает `c` для инстанции `count<int>` и выводит `1`.
- Второй вызов `count(1)` снова увеличивает `c` для той же инстанции `count<int>` и выводит `2`.
- Третий вызов `count(2.3)` создает новую инстанцию `count<double>`, так как аргумент имеет тип `double`, и выводит `1`.
- Четвертый вызов `count<double>(1)` использует уже созданную инстанцию `count<double>`, увеличивает `c` и выводит `2`.

Каждый вызов функции с новым типом аргумента создает новую инстанцию шаблона, что приводит к независимому подсчету для каждого типа.



				Задание 10
Вопрос 5

A) В цикле допущена ошибка на единицу, и попытка получить доступ к элементу массива с индексом 4, которого не существует. Условное выражение в цикле for должно использовать < вместо <=.
B) ptr – указатель на const int. Вы не можете присвоить ему значение 6. Вы можете исправить это, сделав ptr неконстантным.
C) array распадается на указатель, когда он передается в printArray(). Циклы for на основе диапазона не могут работать с указателем на массив, потому что размер массива неизвестен. Одно из решений – добавить параметр длины к функции printArray() и использовать обычный цикл for. Лучшее решение – использовать std::array вместо встроенных фиксированных массивов.
D) temp – это фиксированный массив, но length не является константой времени компиляции, поэтому мы не можем использовать length для создания массива в стиле C. Переменная temp также выйдет из области видимости в конце функции, возвращаемое значение будет указывать на что-то недопустимое. temp должен использовать динамическое выделение памяти или быть std::vector.
E) Вы не можете заставить указатель int указывать на переменную, отличную от int. ptr должен иметь тип double*.


			Задание 11
Вопрос 1
Напишите прототипы функций для следующих случаев. При необходимости используйте const.
a) Функция с именем max(), которая принимает два значения double и возвращает большее из двух.

double max(double x, double y);
b) Функция под названием swap(), которая меняет местами два числа int.
void swap(int &x, int &y);
c) Функция с именем getLargestElement(), которая принимает динамически выделенный массив чисел int и возвращает наибольшее число таким образом, что вызывающий может изменить значение возвращаемого элемента (не забудьте параметр длины).
int& getLargestElement(int *array, int length);



Вопрос 2
Что не так с этими фрагментами кода?
a)doSomething() возвращает ссылку на локальную переменную, которая будет уничтожена при завершении работы doSomething.
b)Функция sumTo() не имеет условия завершения. Значение переменной в конечном итоге станет отрицательным, и функция будет бесконечно вызываться, пока стек не переполнится.
c)Две функции divide не отличаются друг от друга, поскольку у них одинаковые имена и одинаковые параметры. Также существует вероятность проблемы деления на 0.
d)Массив слишком велик для размещения в стеке. Он должен быть размещен динамически.
e)argv[1] может не существовать. Если же он существует, argv[1] является строковым аргументом и не может быть преобразован в целое число с помощью присваивания.
